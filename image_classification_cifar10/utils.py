import pixeltable as pxt

import hydra
import timm
import torch
from PIL.Image import Image
from sklearn.manifold import TSNE
from goldener.describe import GoldDescriptor
from goldener.extract import TorchGoldFeatureExtractor, TorchGoldFeatureExtractorConfig
from goldener.select import GoldSelector
from goldener.reduce import GoldReducer
from goldener.split import GoldSet, GoldSplitter
from goldener.vectorize import (
    TensorVectorizer,
    Filter2DWithCount,
    FilterLocation,
)
from omegaconf import DictConfig
from torchvision.transforms.v2 import Compose, ToTensor, Normalize, Resize

CIFAR10_PREPROCESS = Compose(
    [
        ToTensor(),
        Resize(224),
        Normalize((0.4914, 0.4822, 0.4465), (0.2470, 0.2435, 0.2616)),
    ]
)


def collate_cifar10(
    batch: list[tuple[Image, int, int]],
) -> dict[str, torch.Tensor | list[str] | list[int]]:
    images, targets, indices = zip(*batch)
    imgs_tensor = torch.stack([CIFAR10_PREPROCESS(image) for image in images])
    str_targets = [str(target) for target in targets]
    idx_list = [int(idx) for idx in indices]
    return {
        "data": imgs_tensor,
        "label": str_targets,
        "idx": idx_list,
    }


def get_gold_descriptor(
    table_name: str,
    min_pxt_insert_size: int,
    batch_size: int,
    num_workers: int,
    to_keep_schema: dict,
) -> GoldDescriptor:
    device = (
        torch.device("cpu") if not torch.cuda.is_available() else torch.device("cuda")
    )

    extractor = TorchGoldFeatureExtractor(
        TorchGoldFeatureExtractorConfig(
            model=timm.create_model(
                model_name="vit_small_patch16_dinov3.lvd1689m",
                pretrained=True,
                img_size=224,
                device=device,
            ),
            layers=["blocks.11"],
        )
    )

    return GoldDescriptor(
        table_path=table_name,
        extractor=extractor,
        vectorizer=TensorVectorizer(
            keep=Filter2DWithCount(keep=True, filter_location=FilterLocation.START),
            channel_pos=2,
        ),
        collate_fn=collate_cifar10,
        to_keep_schema=to_keep_schema,
        min_pxt_insert_size=min_pxt_insert_size,
        batch_size=batch_size,
        num_workers=num_workers,
        device=device,
    )


def get_gold_splitter(
    splitter_cfg: DictConfig,
    name_prefix: str,
    train_ratio: float,
    val_ratio: float,
    max_batches: int | None = None,
) -> GoldSplitter:
    splitter_config = hydra.utils.instantiate(splitter_cfg)

    batch_size = splitter_config["batch_size"]
    num_workers = splitter_config["num_workers"]
    min_pxt_insert_size = splitter_config["min_pxt_insert_size"]
    chunk = splitter_config["chunk"]

    table_name = splitter_config["table_name"]

    to_keep_schema = {"label": pxt.String}

    descriptor = get_gold_descriptor(
        table_name=f"{name_prefix}_{table_name}",
        min_pxt_insert_size=min_pxt_insert_size,
        batch_size=batch_size,
        num_workers=num_workers,
        to_keep_schema=to_keep_schema,
    )

    selector = GoldSelector(
        table_path=table_name,
        reducer=GoldReducer(reducer=TSNE(n_components=2, random_state=42)),
        vectorized_key="features",
        class_key="label",
        chunk=chunk,
        to_keep_schema=to_keep_schema,
        batch_size=batch_size,
        num_workers=num_workers,
    )

    sets = [
        GoldSet(name="val", size=val_ratio),
        GoldSet(name="train", size=train_ratio),
    ]

    return GoldSplitter(
        sets=sets,
        descriptor=descriptor,
        vectorizer=None,
        selector=selector,
        max_batches=max_batches,
    )
